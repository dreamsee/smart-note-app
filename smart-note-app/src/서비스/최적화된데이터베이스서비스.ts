// 최적화된 Supabase 데이터베이스 서비스
import { 타입드supabase } from './supabase';
import { 폴더타입, 노트타입, 채팅메시지타입, 폴더설정타입 } from '../타입';

export class 최적화된데이터베이스서비스 {
  
  // ============================================
  // 🚀 최적화된 데이터 로딩 (N+1 쿼리 해결)
  // ============================================
  
  async 폴더목록가져오기(): Promise<폴더타입[]> {
    try {
      // 🔥 1. 모든 데이터를 JOIN으로 한 번에 가져오기 (수정된 구문)
      const { data: 통합데이터, error } = await 타입드supabase
        .from('폴더목록')
        .select(`
          *,
          노트목록 (
            *,
            채팅메시지목록 (*)
          )
        `)
        .order('생성시간', { ascending: true });

      if (error) throw error;
      if (!통합데이터) return [];

      // 🔥 2. 메모리에서 데이터 구조화 (타입 안전 처리)
      const 폴더목록: 폴더타입[] = 통합데이터.map((폴더: any) => ({
        아이디: 폴더.아이디,
        이름: 폴더.이름,
        폴더설정: 폴더.폴더설정 as 폴더설정타입,
        노트목록: (폴더.노트목록 || []).map((노트: any) => ({
          아이디: 노트.아이디,
          제목: 노트.제목,
          내용: 노트.내용,
          요약: 노트.요약 || undefined,
          태그목록: 노트.태그목록 || undefined,
          노트설정: 노트.노트설정 || undefined,
          생성시간: new Date(노트.생성시간),
          수정시간: new Date(노트.수정시간),
          채팅메시지목록: this.메시지구조화하기(노트.채팅메시지목록 || [])
        }))
      }));

      console.log(`✅ 최적화된 로딩 완료: ${통합데이터.length}개 폴더, 1회 쿼리`);
      return 폴더목록;

    } catch (에러) {
      console.error('최적화된 데이터 로드 실패:', 에러);
      throw 에러;
    }
  }

  // 🔥 메시지 구조화 (하위메시지 포함) - 단순화 버전
  private 메시지구조화하기(메시지목록: any[]): 채팅메시지타입[] {
    if (!메시지목록 || 메시지목록.length === 0) return [];
    
    const 메시지맵 = new Map<string, 채팅메시지타입>();
    
    // 1단계: 모든 메시지를 맵에 저장
    메시지목록.forEach(메시지 => {
      메시지맵.set(메시지.아이디, {
        아이디: 메시지.아이디,
        텍스트: 메시지.텍스트,
        타임스탬프: new Date(메시지.타임스탬프),
        작성자: 메시지.작성자 || undefined,
        카테고리: 메시지.카테고리 || undefined,
        말풍선위치: 메시지.말풍선위치 as '왼쪽' | '오른쪽' || undefined,
        하위메시지목록: []
      });
    });

    // 2단계: 하위메시지 관계 설정
    메시지목록.forEach(메시지 => {
      if (메시지.부모메시지아이디) {
        const 부모메시지 = 메시지맵.get(메시지.부모메시지아이디);
        const 현재메시지 = 메시지맵.get(메시지.아이디);
        if (부모메시지 && 현재메시지) {
          부모메시지.하위메시지목록!.push(현재메시지);
        }
      }
    });

    // 3단계: 루트 메시지만 반환 (부모가 없는 메시지)
    return Array.from(메시지맵.values())
      .filter(메시지 => !메시지목록.find(원본 => 원본.아이디 === 메시지.아이디 && 원본.부모메시지아이디))
      .sort((a, b) => a.타임스탬프.getTime() - b.타임스탬프.getTime());
  }

  // ============================================
  // 🚀 증분 업데이트 (변경된 부분만 동기화)
  // ============================================

  async 증분업데이트하기(마지막동기화시간: Date): Promise<Partial<폴더타입>[]> {
    try {
      // 단순화된 증분 업데이트 (복잡한 JOIN 대신 기본 쿼리 사용)
      const { data: 변경된폴더, error } = await 타입드supabase
        .from('폴더목록')
        .select(`
          *,
          노트목록 (
            *,
            채팅메시지목록 (*)
          )
        `)
        .gt('수정시간', 마지막동기화시간.toISOString())
        .order('수정시간', { ascending: false });

      if (error) throw error;

      console.log(`✅ 증분 업데이트: ${변경된폴더?.length || 0}개 항목 변경`);
      return 변경된폴더?.map((폴더: any) => ({
        아이디: 폴더.아이디,
        이름: 폴더.이름,
        폴더설정: 폴더.폴더설정 as 폴더설정타입,
        노트목록: (폴더.노트목록 || []).map((노트: any) => ({
          아이디: 노트.아이디,
          제목: 노트.제목,
          내용: 노트.내용,
          요약: 노트.요약 || undefined,
          태그목록: 노트.태그목록 || undefined,
          노트설정: 노트.노트설정 || undefined,
          생성시간: new Date(노트.생성시간),
          수정시간: new Date(노트.수정시간),
          채팅메시지목록: this.메시지구조화하기(노트.채팅메시지목록 || [])
        }))
      })) || [];

    } catch (에러) {
      console.error('증분 업데이트 실패:', 에러);
      throw 에러;
    }
  }

  // ============================================
  // 🚀 병렬 처리 최적화
  // ============================================

  async 병렬폴더목록가져오기(): Promise<폴더타입[]> {
    try {
      // 1. 폴더 목록 먼저 가져오기
      const { data: 폴더데이터, error: 폴더에러 } = await 타입드supabase
        .from('폴더목록')
        .select('*')
        .order('생성시간', { ascending: true });

      if (폴더에러 || !폴더데이터) throw 폴더에러;

      // 2. 모든 폴더의 노트를 병렬로 가져오기
      const 노트결과목록 = await Promise.all(
        폴더데이터.map(async (폴더) => {
          const { data: 노트데이터, error: 노트에러 } = await 타입드supabase
            .from('노트목록')
            .select(`
              *,
              채팅메시지목록(
                *,
                하위메시지:채팅메시지목록!채팅메시지목록_부모메시지아이디_fkey(*)
              )
            `)
            .eq('폴더아이디', 폴더.아이디)
            .order('생성시간', { ascending: true });

          if (노트에러) throw 노트에러;
          return { 폴더, 노트목록: 노트데이터 || [] };
        })
      );

      // 3. 결과 구조화
      const 폴더목록: 폴더타입[] = 노트결과목록.map(({ 폴더, 노트목록 }) => ({
        아이디: 폴더.아이디,
        이름: 폴더.이름,
        폴더설정: 폴더.폴더설정 as 폴더설정타입,
        노트목록: 노트목록.map((노트: any) => ({
          아이디: 노트.아이디,
          제목: 노트.제목,
          내용: 노트.내용,
          요약: 노트.요약 || undefined,
          태그목록: 노트.태그목록 || undefined,
          노트설정: 노트.노트설정 || undefined,
          생성시간: new Date(노트.생성시간),
          수정시간: new Date(노트.수정시간),
          채팅메시지목록: this.메시지구조화하기(노트.채팅메시지목록 || [])
        }))
      }));

      console.log(`✅ 병렬 로딩 완료: ${폴더목록.length}개 폴더`);
      return 폴더목록;

    } catch (에러) {
      console.error('병렬 데이터 로드 실패:', 에러);
      throw 에러;
    }
  }

  // ============================================
  // 🚀 스마트 캐싱 시스템
  // ============================================

  private 캐시저장소 = new Map<string, { 데이터: any; 만료시간: number }>();
  private 캐시유효시간 = 5 * 60 * 1000; // 5분

  async 캐시된폴더목록가져오기(): Promise<폴더타입[]> {
    const 캐시키 = 'folder-list';
    const 캐시된항목 = this.캐시저장소.get(캐시키);

    // 캐시가 유효한 경우
    if (캐시된항목 && Date.now() < 캐시된항목.만료시간) {
      console.log('✅ 캐시에서 데이터 반환');
      return 캐시된항목.데이터;
    }

    // 캐시가 없거나 만료된 경우 새로 로드
    const 새데이터 = await this.폴더목록가져오기();
    
    // 캐시에 저장
    this.캐시저장소.set(캐시키, {
      데이터: 새데이터,
      만료시간: Date.now() + this.캐시유효시간
    });

    return 새데이터;
  }

  // 캐시 무효화
  캐시무효화하기(키?: string) {
    if (키) {
      this.캐시저장소.delete(키);
    } else {
      this.캐시저장소.clear();
    }
    console.log('✅ 캐시 무효화 완료');
  }
}

// 싱글톤 인스턴스
export const 최적화된데이터베이스 = new 최적화된데이터베이스서비스();