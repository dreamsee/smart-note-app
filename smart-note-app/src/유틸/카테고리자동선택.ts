import { 카테고리자동선택타입 } from '../타입';

// 카테고리 자동 선택 유틸리티 함수들

/**
 * 현재 시간을 시간대 키로 변환 (0-23)
 * @returns 시간대 키 (예: "09", "14", "22")
 */
export const 현재시간대키가져오기 = (): string => {
  const 현재시간 = new Date();
  return 현재시간.getHours().toString().padStart(2, '0');
};

/**
 * 카테고리 사용 학습 데이터 업데이트
 * @param 현재설정 기존 자동선택 설정
 * @param 선택된카테고리 사용자가 선택한 카테고리
 * @param 이전카테고리 이전에 선택했던 카테고리 (선택사항)
 * @returns 업데이트된 설정
 */
export const 카테고리사용학습하기 = (
  현재설정: 카테고리자동선택타입 | undefined,
  선택된카테고리: string,
  이전카테고리?: string
): 카테고리자동선택타입 => {
  const 현재시간 = new Date();
  const 시간대키 = 현재시간대키가져오기();
  
  // 기본 설정이 없으면 초기화
  const 설정: 카테고리자동선택타입 = 현재설정 || {
    활성화: true,
    시간대별설정: {},
    연속패턴통계: {},
    사용빈도통계: {},
    학습데이터갯수: 0
  };

  // 1. 시간대별 설정 업데이트 (가장 많이 사용하는 카테고리로 설정)
  const 시간대별통계키 = `시간대_${시간대키}`;
  if (!설정.사용빈도통계[시간대별통계키]) {
    설정.사용빈도통계[시간대별통계키] = 0;
  }
  설정.사용빈도통계[시간대별통계키]++;
  
  // 현재 시간대에서 가장 많이 사용한 카테고리 찾기
  const 시간대통계 = Object.keys(설정.사용빈도통계)
    .filter(키 => 키.startsWith(`시간대_${시간대키}_`))
    .reduce((통계, 키) => {
      const 카테고리 = 키.replace(`시간대_${시간대키}_`, '');
      통계[카테고리] = (통계[카테고리] || 0) + 설정.사용빈도통계[키];
      return 통계;
    }, {} as { [카테고리: string]: number });

  const 시간대별카테고리키 = `시간대_${시간대키}_${선택된카테고리}`;
  설정.사용빈도통계[시간대별카테고리키] = (설정.사용빈도통계[시간대별카테고리키] || 0) + 1;

  // 시간대별 기본 카테고리 결정 (5번 이상 사용된 것 중 최다)
  const 최다사용카테고리 = Object.entries(시간대통계)
    .filter(([, 횟수]) => 횟수 >= 5)
    .sort(([, a], [, b]) => b - a)[0];
  
  if (최다사용카테고리) {
    설정.시간대별설정[시간대키] = 최다사용카테고리[0];
  }

  // 2. 연속 패턴 통계 업데이트
  if (이전카테고리 && 이전카테고리 !== 선택된카테고리) {
    if (!설정.연속패턴통계[이전카테고리]) {
      설정.연속패턴통계[이전카테고리] = {};
    }
    설정.연속패턴통계[이전카테고리][선택된카테고리] = 
      (설정.연속패턴통계[이전카테고리][선택된카테고리] || 0) + 1;
  }

  // 3. 전체 사용 빈도 통계 업데이트
  설정.사용빈도통계[선택된카테고리] = (설정.사용빈도통계[선택된카테고리] || 0) + 1;

  // 4. 마지막 사용 정보 업데이트
  설정.마지막사용카테고리 = 선택된카테고리;
  설정.마지막사용시간 = 현재시간;
  설정.학습데이터갯수++;

  return 설정;
};

/**
 * 추천 카테고리 예측
 * @param 설정 자동선택 설정
 * @param 사용가능카테고리목록 현재 폴더의 카테고리 목록
 * @returns 예측된 카테고리와 신뢰도 (0-1)
 */
export const 추천카테고리예측하기 = (
  설정: 카테고리자동선택타입 | undefined,
  사용가능카테고리목록: string[]
): { 카테고리: string; 신뢰도: number } | null => {
  if (!설정 || !설정.활성화 || 사용가능카테고리목록.length === 0) {
    return null;
  }

  const 현재시간대키 = 현재시간대키가져오기();
  const 점수맵: { [카테고리: string]: number } = {};

  // 사용 가능한 카테고리들만 대상으로 점수 계산
  for (const 카테고리 of 사용가능카테고리목록) {
    점수맵[카테고리] = 0;

    // 1. 시간대별 점수 (가중치 40%)
    if (설정.시간대별설정[현재시간대키] === 카테고리) {
      점수맵[카테고리] += 40;
    }

    // 2. 연속 패턴 점수 (가중치 35%)
    if (설정.마지막사용카테고리 && 설정.연속패턴통계[설정.마지막사용카테고리]) {
      const 패턴횟수 = 설정.연속패턴통계[설정.마지막사용카테고리][카테고리] || 0;
      const 총패턴횟수 = Object.values(설정.연속패턴통계[설정.마지막사용카테고리])
        .reduce((합계, 횟수) => 합계 + 횟수, 0);
      
      if (총패턴횟수 > 0) {
        const 패턴확률 = 패턴횟수 / 총패턴횟수;
        점수맵[카테고리] += 패턴확률 * 35;
      }
    }

    // 3. 전체 사용 빈도 점수 (가중치 25%)
    const 사용횟수 = 설정.사용빈도통계[카테고리] || 0;
    const 총사용횟수 = Object.values(설정.사용빈도통계)
      .filter(값 => typeof 값 === 'number')
      .reduce((합계, 횟수) => 합계 + 횟수, 0);
    
    if (총사용횟수 > 0) {
      const 사용확률 = 사용횟수 / 총사용횟수;
      점수맵[카테고리] += 사용확률 * 25;
    }
  }

  // 가장 높은 점수의 카테고리 선택
  const 정렬된점수 = Object.entries(점수맵)
    .sort(([, 점수a], [, 점수b]) => 점수b - 점수a);

  if (정렬된점수.length === 0 || 정렬된점수[0][1] < 10) {
    return null; // 신뢰도가 너무 낮으면 예측하지 않음
  }

  const [추천카테고리, 점수] = 정렬된점수[0];
  const 신뢰도 = Math.min(점수 / 100, 1); // 100점 만점을 1.0 신뢰도로 변환

  return {
    카테고리: 추천카테고리,
    신뢰도: 신뢰도
  };
};

/**
 * 자동선택 설정 초기화
 * @returns 기본 설정
 */
export const 자동선택설정초기화 = (): 카테고리자동선택타입 => {
  return {
    활성화: true,
    시간대별설정: {},
    연속패턴통계: {},
    사용빈도통계: {},
    학습데이터갯수: 0
  };
};

/**
 * 학습 데이터 정리 (30일 이상 된 데이터 가중치 감소)
 * @param 설정 현재 설정
 * @returns 정리된 설정
 */
export const 학습데이터정리하기 = (설정: 카테고리자동선택타입): 카테고리자동선택타입 => {
  // 데이터가 너무 많이 쌓이면 가중치 감소
  if (설정.학습데이터갯수 > 1000) {
    const 정리된설정 = { ...설정 };
    
    // 모든 통계를 절반으로 감소
    for (const 키 of Object.keys(정리된설정.사용빈도통계)) {
      정리된설정.사용빈도통계[키] = Math.ceil(정리된설정.사용빈도통계[키] / 2);
    }
    
    for (const 이전카테고리 of Object.keys(정리된설정.연속패턴통계)) {
      for (const 다음카테고리 of Object.keys(정리된설정.연속패턴통계[이전카테고리])) {
        정리된설정.연속패턴통계[이전카테고리][다음카테고리] = 
          Math.ceil(정리된설정.연속패턴통계[이전카테고리][다음카테고리] / 2);
      }
    }
    
    정리된설정.학습데이터갯수 = Math.ceil(정리된설정.학습데이터갯수 / 2);
    
    return 정리된설정;
  }
  
  return 설정;
};