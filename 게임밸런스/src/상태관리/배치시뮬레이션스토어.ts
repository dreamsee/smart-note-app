import { create } from 'zustand'
import { 
  배치시뮬레이션타입, 
  배치캐릭터타입, 
  바둑판타입, 
  배치정보타입, 
  위치타입,
  배치전투결과타입
} from '../타입'

interface 배치시뮬레이션스토어타입 {
  // 상태
  시뮬레이션: 배치시뮬레이션타입 | null;
  선택캐릭터: 배치캐릭터타입 | null;
  현재모드: '배치' | '이동' | '공격';
  전투결과: 배치전투결과타입 | null;
  
  // 액션
  바둑판크기설정: (가로: number, 세로: number) => void;
  캐릭터배치: (캐릭터: 배치캐릭터타입, 위치: 위치타입) => void;
  캐릭터선택: (캐릭터: 배치캐릭터타입 | null) => void;
  캐릭터이동: (캐릭터아이디: string, 새위치: 위치타입) => void;
  캐릭터공격: (공격자아이디: string, 대상위치: 위치타입) => void;
  모드변경: (모드: '배치' | '이동' | '공격') => void;
  턴종료: () => void;
  전투시작: () => void;
  전투초기화: () => void;
  이동범위계산: (캐릭터: 배치캐릭터타입) => void;
  공격범위계산: (캐릭터: 배치캐릭터타입) => void;
}

// 초기 바둑판 생성
const 초기바둑판생성 = (가로: number, 세로: number): 바둑판타입 => {
  const 배치정보: 배치정보타입[][] = []
  
  for (let y = 0; y < 세로; y++) {
    배치정보[y] = []
    for (let x = 0; x < 가로; x++) {
      배치정보[y][x] = {
        점유됨: false,
        이동가능: false,
        공격범위내: false
      }
    }
  }
  
  return {
    가로,
    세로,
    배치정보
  }
}

// 초기 캐릭터 목록 생성
const 초기캐릭터목록생성 = (): 배치캐릭터타입[] => {
  return [
    {
      아이디: '아군1',
      이름: '강철 전사',
      레벨: 50,
      체력: 1500,
      현재체력: 1500,
      공격력: 120,
      방어력: 80,
      속도: 60,
      클래스: '전사',
      등급: '영웅',
      이동범위: 2,
      공격범위: 1,
      팀: '아군',
      행동완료: false,
      상태효과: []
    },
    {
      아이디: '아군2',
      이름: '화염 마법사',
      레벨: 45,
      체력: 800,
      현재체력: 800,
      공격력: 180,
      방어력: 40,
      속도: 70,
      클래스: '마법사',
      등급: '영웅',
      이동범위: 1,
      공격범위: 3,
      팀: '아군',
      행동완료: false,
      상태효과: []
    },
    {
      아이디: '적군1',
      이름: '그림자 자객',
      레벨: 48,
      체력: 900,
      현재체력: 900,
      공격력: 200,
      방어력: 50,
      속도: 95,
      클래스: '도적',
      등급: '영웅',
      이동범위: 3,
      공격범위: 1,
      팀: '적군',
      행동완료: false,
      상태효과: []
    },
    {
      아이디: '적군2',
      이름: '얼음 궁수',
      레벨: 47,
      체력: 750,
      현재체력: 750,
      공격력: 150,
      방어력: 60,
      속도: 80,
      클래스: '궁수',
      등급: '영웅',
      이동범위: 2,
      공격범위: 4,
      팀: '적군',
      행동완료: false,
      상태효과: []
    }
  ]
}

// 거리 계산 함수
const 거리계산 = (위치1: 위치타입, 위치2: 위치타입): number => {
  return Math.abs(위치1.x - 위치2.x) + Math.abs(위치1.y - 위치2.y)
}

export const 배치시뮬레이션스토어 = create<배치시뮬레이션스토어타입>((set, get) => ({
  // 초기 상태
  시뮬레이션: {
    바둑판: 초기바둑판생성(5, 5),
    배치캐릭터목록: 초기캐릭터목록생성(),
    현재턴: 1,
    진행상태: '준비중',
    승리조건: '전멸'
  },
  선택캐릭터: null,
  현재모드: '배치',
  전투결과: null,

  // 바둑판 크기 설정
  바둑판크기설정: (가로: number, 세로: number) => {
    set((상태) => ({
      시뮬레이션: 상태.시뮬레이션 ? {
        ...상태.시뮬레이션,
        바둑판: 초기바둑판생성(가로, 세로),
        배치캐릭터목록: 상태.시뮬레이션.배치캐릭터목록.map(캐릭터 => ({
          ...캐릭터,
          위치: undefined // 크기 변경시 모든 캐릭터 위치 초기화
        }))
      } : null,
      선택캐릭터: null
    }))
  },

  // 캐릭터 배치
  캐릭터배치: (캐릭터: 배치캐릭터타입, 위치: 위치타입) => {
    set((상태) => {
      if (!상태.시뮬레이션) return 상태

      // 해당 위치에 이미 캐릭터가 있는지 확인
      const 기존캐릭터 = 상태.시뮬레이션.배치캐릭터목록.find(c => 
        c.위치?.x === 위치.x && c.위치?.y === 위치.y
      )
      
      if (기존캐릭터) return 상태 // 이미 점유된 위치

      const 새배치정보 = [...상태.시뮬레이션.바둑판.배치정보]
      
      // 이전 위치 해제
      if (캐릭터.위치) {
        새배치정보[캐릭터.위치.y][캐릭터.위치.x] = {
          ...새배치정보[캐릭터.위치.y][캐릭터.위치.x],
          점유됨: false,
          캐릭터아이디: undefined
        }
      }
      
      // 새 위치 설정
      새배치정보[위치.y][위치.x] = {
        ...새배치정보[위치.y][위치.x],
        점유됨: true,
        캐릭터아이디: 캐릭터.아이디
      }

      return {
        시뮬레이션: {
          ...상태.시뮬레이션,
          바둑판: {
            ...상태.시뮬레이션.바둑판,
            배치정보: 새배치정보
          },
          배치캐릭터목록: 상태.시뮬레이션.배치캐릭터목록.map(c =>
            c.아이디 === 캐릭터.아이디 ? { ...c, 위치 } : c
          )
        }
      }
    })
  },

  // 캐릭터 선택
  캐릭터선택: (캐릭터: 배치캐릭터타입 | null) => {
    set({ 선택캐릭터: 캐릭터 })
    
    // 선택된 캐릭터의 이동/공격 범위 계산
    if (캐릭터) {
      const { 이동범위계산, 공격범위계산, 현재모드 } = get()
      if (현재모드 === '이동') {
        이동범위계산(캐릭터)
      } else if (현재모드 === '공격') {
        공격범위계산(캐릭터)
      }
    }
  },

  // 캐릭터 이동
  캐릭터이동: (캐릭터아이디: string, 새위치: 위치타입) => {
    const 상태 = get()
    if (!상태.시뮬레이션) return

    const 캐릭터 = 상태.시뮬레이션.배치캐릭터목록.find(c => c.아이디 === 캐릭터아이디)
    if (!캐릭터 || !캐릭터.위치) return

    // 이동 가능한지 확인
    const 거리 = 거리계산(캐릭터.위치, 새위치)
    if (거리 > 캐릭터.이동범위) return

    상태.캐릭터배치(캐릭터, 새위치)
  },

  // 캐릭터 공격
  캐릭터공격: (공격자아이디: string, 대상위치: 위치타입) => {
    set((상태) => {
      if (!상태.시뮬레이션) return 상태

      const 공격자 = 상태.시뮬레이션.배치캐릭터목록.find(c => c.아이디 === 공격자아이디)
      const 대상 = 상태.시뮬레이션.배치캐릭터목록.find(c => 
        c.위치?.x === 대상위치.x && c.위치?.y === 대상위치.y
      )

      if (!공격자 || !공격자.위치 || !대상) return 상태

      // 공격 범위 확인
      const 거리 = 거리계산(공격자.위치, 대상위치)
      if (거리 > 공격자.공격범위) return 상태

      // 데미지 계산
      const 데미지 = Math.max(1, 공격자.공격력 - 대상.방어력)
      const 새체력 = Math.max(0, 대상.현재체력 - 데미지)

      return {
        시뮬레이션: {
          ...상태.시뮬레이션,
          배치캐릭터목록: 상태.시뮬레이션.배치캐릭터목록.map(c =>
            c.아이디 === 대상.아이디 ? { ...c, 현재체력: 새체력 } :
            c.아이디 === 공격자.아이디 ? { ...c, 행동완료: true } : c
          )
        }
      }
    })
  },

  // 모드 변경
  모드변경: (모드: '배치' | '이동' | '공격') => {
    set({ 현재모드: 모드 })
    
    // 범위 초기화
    const { 시뮬레이션 } = get()
    if (시뮬레이션) {
      const 새배치정보 = 시뮬레이션.바둑판.배치정보.map(row =>
        row.map(cell => ({
          ...cell,
          이동가능: false,
          공격범위내: false
        }))
      )
      
      set((상태) => ({
        시뮬레이션: 상태.시뮬레이션 ? {
          ...상태.시뮬레이션,
          바둑판: {
            ...상태.시뮬레이션.바둑판,
            배치정보: 새배치정보
          }
        } : null
      }))
    }
  },

  // 이동 범위 계산
  이동범위계산: (캐릭터: 배치캐릭터타입) => {
    set((상태) => {
      if (!상태.시뮬레이션 || !캐릭터.위치) return 상태

      const 새배치정보 = 상태.시뮬레이션.바둑판.배치정보.map(row =>
        row.map(cell => ({ ...cell, 이동가능: false }))
      )

      // 이동 가능한 위치 계산
      for (let y = 0; y < 상태.시뮬레이션.바둑판.세로; y++) {
        for (let x = 0; x < 상태.시뮬레이션.바둑판.가로; x++) {
          const 거리 = 거리계산(캐릭터.위치, { x, y })
          if (거리 <= 캐릭터.이동범위 && !새배치정보[y][x].점유됨) {
            새배치정보[y][x].이동가능 = true
          }
        }
      }

      return {
        시뮬레이션: {
          ...상태.시뮬레이션,
          바둑판: {
            ...상태.시뮬레이션.바둑판,
            배치정보: 새배치정보
          }
        }
      }
    })
  },

  // 공격 범위 계산
  공격범위계산: (캐릭터: 배치캐릭터타입) => {
    set((상태) => {
      if (!상태.시뮬레이션 || !캐릭터.위치) return 상태

      const 새배치정보 = 상태.시뮬레이션.바둑판.배치정보.map(row =>
        row.map(cell => ({ ...cell, 공격범위내: false }))
      )

      // 공격 가능한 위치 계산
      for (let y = 0; y < 상태.시뮬레이션.바둑판.세로; y++) {
        for (let x = 0; x < 상태.시뮬레이션.바둑판.가로; x++) {
          const 거리 = 거리계산(캐릭터.위치, { x, y })
          if (거리 <= 캐릭터.공격범위) {
            새배치정보[y][x].공격범위내 = true
          }
        }
      }

      return {
        시뮬레이션: {
          ...상태.시뮬레이션,
          바둑판: {
            ...상태.시뮬레이션.바둑판,
            배치정보: 새배치정보
          }
        }
      }
    })
  },

  // 턴 종료
  턴종료: () => {
    set((상태) => {
      if (!상태.시뮬레이션) return 상태

      // 모든 캐릭터 행동 완료 상태 초기화
      const 새캐릭터목록 = 상태.시뮬레이션.배치캐릭터목록.map(c => ({
        ...c,
        행동완료: false
      }))

      return {
        시뮬레이션: {
          ...상태.시뮬레이션,
          배치캐릭터목록: 새캐릭터목록,
          현재턴: 상태.시뮬레이션.현재턴 + 1
        },
        선택캐릭터: null
      }
    })
  },

  // 전투 시작
  전투시작: () => {
    set((상태) => ({
      시뮬레이션: 상태.시뮬레이션 ? {
        ...상태.시뮬레이션,
        진행상태: '진행중'
      } : null,
      현재모드: '이동'
    }))
  },

  // 전투 초기화
  전투초기화: () => {
    set({
      시뮬레이션: {
        바둑판: 초기바둑판생성(5, 5),
        배치캐릭터목록: 초기캐릭터목록생성(),
        현재턴: 1,
        진행상태: '준비중',
        승리조건: '전멸'
      },
      선택캐릭터: null,
      현재모드: '배치',
      전투결과: null
    })
  }
}))